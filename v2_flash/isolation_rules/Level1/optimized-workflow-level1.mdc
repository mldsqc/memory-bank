---
description: Optimized Level 1 workflow for quick bug fixes with token efficiency
globs: "**/level1*/**", "**/quick*/**", "**/bugfix*/**"
alwaysApply: false
---

# OPTIMIZED LEVEL 1 WORKFLOW

> **TL;DR:** This streamlined workflow for Level 1 tasks (quick bug fixes) optimizes for speed and token efficiency while maintaining quality.

## ğŸ”§ LEVEL 1 PROCESS FLOW

```mermaid
graph TD
    Start["START LEVEL 1<br>QUICK FIX"] --> Analyze["1ï¸âƒ£ ANALYZE<br>Understand issue"]
    Analyze --> Implement["2ï¸âƒ£ IMPLEMENT<br>Fix the issue"]
    Implement --> Verify["3ï¸âƒ£ VERIFY<br>Test the fix"]
    Verify --> Document["4ï¸âƒ£ DOCUMENT<br>Record solution"]

```

## ğŸ“ CONSOLIDATED DOCUMENTATION

Level 1 tasks use a single-file approach to minimize context switching:

```markdown
# QUICK FIX: [Issue Name]

## Issue Summary
- Type: [Bug/Hotfix/Quick Enhancement]
- Priority: [Low/Medium/High/Critical]
- Reported by: [Name/System]
- Affected area: [Component/Feature]

## Analysis
- Root cause: [Brief description]
- Affected files: [List of files]
- Impact: [Scope of impact]

## Solution
- Approach: [Brief description]
- Changes made: [List of changes]
- Commands executed: [Key commands]

## Verification
- Testing: [How the fix was tested]
- Results: [Test results]
- Additional checks: [Any other verification]

## Status
- [x] Fix implemented
- [x] Tests passed
- [x] Documentation updated
```

## ğŸ”„ MEMORY BANK UPDATE

Level 1 tasks use a simplified Memory Bank update with minimal overhead:

```markdown
## tasks.md Update (Level 1)

### Task: [Task Name]
- Status: Complete
- Implementation: [One-line summary]
- Link to fix: [File/line reference]
```

## âš¡ TOKEN-OPTIMIZED TEMPLATE

For maximum efficiency, Level 1 tasks can use this ultra-compact template:

```markdown
## ğŸ”§ FIX: [Issue]
ğŸ“Œ Problem: [Brief description]
ğŸ” Cause: [Root cause]
ğŸ› ï¸ Solution: [Implemented fix]
âœ… Tested: [Verification method]
```

## ğŸ“Š QUICK TEMPLATES FOR COMMON ISSUES

### Performance Fix
```markdown
## ğŸ”§ FIX: Performance issue in [component]
ğŸ“Œ Problem: Slow response times in [component]
ğŸ” Cause: Inefficient query/algorithm
ğŸ› ï¸ Solution: Optimized [specific optimization]
âœ… Tested: Response time improved from [X]ms to [Y]ms
```

### Bug Fix
```markdown
## ğŸ”§ FIX: Bug in [component]
ğŸ“Œ Problem: [Specific behavior] not working correctly
ğŸ” Cause: [Root cause analysis]
ğŸ› ï¸ Solution: Fixed by [implementation details]
âœ… Tested: Verified with [test approach]
```

### Quick Enhancement
```markdown
## ğŸ”§ ENHANCEMENT: [Feature]
ğŸ“Œ Request: Add [specific capability]
ğŸ› ï¸ Implementation: Added by [implementation details]
âœ… Tested: Verified with [test approach]
```

## âœ… STREAMLINED VERIFICATION

Level 1 tasks use a minimal verification process:

```markdown
VERIFICATION:
[x] Fix implemented and tested
[x] No regressions introduced
[x] Documentation updated
```

## ğŸš€ CONSOLIDATED MEMORY BANK UPDATE

Optimize Memory Bank updates for Level 1 tasks by using a single operation.
**Instructions:** Update `tasks.md` by appending the completion status and `activeContext.md` / `progress.md` with a brief one-line summary if relevant.

## ğŸ”„ OPTIMIZED LEVEL 1 WORKFLOW EXAMPLE

```markdown
## ğŸ”§ FIX: Login button not working on mobile devices

ğŸ“Œ Problem: 
Users unable to log in on mobile devices, button appears but doesn't trigger authentication

ğŸ” Cause:
Event listener using desktop-specific event (mousedown instead of handling touch events)

ğŸ› ï¸ Solution:
Updated event handling to use event delegation and support both mouse and touch events:
```js
// Before: 
loginButton.addEventListener('mousedown', handleLogin);

// After:
loginButton.addEventListener('mousedown', handleLogin);
loginButton.addEventListener('touchstart', handleLogin);
```

âœ… Tested:
- Verified on iOS Safari and Android Chrome 
- Login now works on all tested mobile devices
- No regression on desktop browsers
```

## âš¡ TOKEN EFFICIENCY BENEFITS

This optimized Level 1 workflow provides:

1.  Reduced documentation overhead.
2.  Consolidated Memory Bank updates.
3.  Focused verification process.
4.  Template-based approach for common scenarios.
5.  Streamlined workflow with fewer steps.

The updated approach maintains all critical information while significantly reducing token usage.